{"meta":{"title":"cxkの博客","subtitle":"不负当下，不念过往，不惧明天","description":"积跬步而至千里","author":"XuKun Chen","url":"https://xkunchen.github.io","root":"/"},"pages":[{"title":"","date":"2019-08-27T07:55:27.000Z","updated":"2019-10-16T08:44:37.617Z","comments":false,"path":"categories/index.html","permalink":"https://xkunchen.github.io/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"about","date":"2019-08-27T09:01:36.000Z","updated":"2019-10-16T01:57:39.586Z","comments":false,"path":"about/index.html","permalink":"https://xkunchen.github.io/about/index.html","excerpt":"","text":"个人简介 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"contact","date":"2020-03-06T07:58:45.000Z","updated":"2020-03-06T08:01:22.589Z","comments":true,"path":"contact/index.html","permalink":"https://xkunchen.github.io/contact/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"category","date":"2019-08-27T09:01:36.000Z","updated":"2019-10-12T02:16:03.311Z","comments":true,"path":"category/index.html","permalink":"https://xkunchen.github.io/category/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tag","date":"2019-08-27T09:01:36.000Z","updated":"2019-10-12T02:17:01.428Z","comments":true,"path":"tag/index.html","permalink":"https://xkunchen.github.io/tag/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"friends","date":"2020-03-06T08:01:49.000Z","updated":"2020-03-06T08:02:40.900Z","comments":true,"path":"friends/index.html","permalink":"https://xkunchen.github.io/friends/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"","date":"2019-08-27T07:42:41.000Z","updated":"2019-10-16T08:44:53.728Z","comments":false,"path":"tags/index.html","permalink":"https://xkunchen.github.io/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"HTTP详解","slug":"HTTP详解","date":"2020-03-16T07:30:31.000Z","updated":"2020-03-16T07:34:30.458Z","comments":true,"path":"2020/03/16/http-xiang-jie/","link":"","permalink":"https://xkunchen.github.io/2020/03/16/http-xiang-jie/","excerpt":"","text":"面试官，别问我 HTTP 了！看这 30 张图就行！PS:以下文章来源于公众号小林coding ，作者小林coding，本人觉得不错就先收藏起来。 前言在面试过程中，HTTP 被提问的概率还是比较高的。 这里搜集了 5 大类 HTTP 面试常问的题目，同时这 5 大类题跟 HTTP 的发展和演变关联性是比较大的，通过问答 + 图解的形式由浅入深的方式帮助大家进一步的学习和理解 HTTP 协议。 应该说HTTP和HTTPS部分的面试题，看这些基本就够了。 HTTP 基本概念 Get 与 Post HTTP 特性 HTTPS 与 HTTP HTTP/1.1、HTTP/2、HTTP/3 演变 提纲 正文01 HTTP 基本概念 HTTP 是什么？描述一下 HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。 能否详细解释「超文本传输协议」？ HTTP的名字「超文本协议传输」，它可以拆成三个部分： 超文本 传输 协议 三个部分 1. 「协议」 在生活中，我们也能随处可见「协议」，例如： 刚毕业时会签一个「三方协议」； 找房子时会签一个「租房协议」； 三方协议和租房协议 生活中的协议，本质上与计算机中的协议是相同的，协议的特点: 「协」字，代表的意思是必须有两个以上的参与者。例如三方协议里的参与者有三个：你、公司、学校三个；租房协议里的参与者有两个：你和房东。 「仪」字，代表的意思是对参与者的一种行为约定和规范。例如三方协议里规定试用期期限、毁约金等；租房协议里规定租期期限、每月租金金额、违约如何处理等。 针对 HTTP 协议，我们可以这么理解。 HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（两个以上的参与者），以及相关的各种控制和错误处理方式（行为约定和规范）。 2. 「传输」 所谓的「传输」，很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点 搬到 A 点。 别轻视了这个简单的动作，它至少包含两项重要的信息。 HTTP 协议是一个双向协议。 我们在上网冲浪时，浏览器是请求方 A ，百度网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。 请求 - 应答 数据虽然是在 A 和 B 之间传输，但允许中间有中转或接力。 就好像第一排的同学想穿递纸条给最后一排的同学，那么传递的过程中就需要经过好多个同学（中间人），这样的传输方式就从「A &lt; — &gt; B」，变成了「A &lt;-&gt; N &lt;-&gt; M &lt;-&gt; B」。 而在 HTTP 里，需要中间人遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。 针对传输，我们可以进一步理解了 HTTP。 HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。 3. 「超文本」 HTTP 传输的内容是「超文本」。 我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」。的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算做「文本」。 再来理解「超文本」，它就是超越了普通文本的文本，它是文字、图片、视频等的混合体最关键有超链接，能从一个超文本跳转到另外一个超文本。 HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，在经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。 OK，经过了对 HTTP 里这三个名词的详细解释，就可以给出比「超文本传输协议」这七个字更准确更有技术含量的答案： HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。 那「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议HTTP」 ，这种说法正确吗？ 这种说法是不正确的。因为也可以是「服务器&lt; – &gt;服务器」，所以采用两点之间的描述会更准确。 HTTP 常见的状态码，有哪些？ 五大类 HTTP 状态码 1xx 1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。 2xx 2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。 「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。 「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。 「206 Partial Content」是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。 3xx 3xx 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。 「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。 「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。 301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。 「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。 4xx 4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。 「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。 「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。 「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。 5xx 5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。 「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。 「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。 「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。 「503 Service Unavailable」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。 http 常见字段有哪些？ Host 客户端发送请求时，用来指定服务器的域名。 Host: www.A.com有了 Host 字段，就可以将请求发往「同一台」服务器上的不同网站。 Content-Length 字段 服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。 Content-Length: 1000如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。 Connection 字段 Connection 字段最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。 HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 Connection 首部字段的值为 Keep-Alive。 Connection: keep-alive一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。 Content-Type 字段 Content-Type 字段用于服务器回应时，告诉客户端，本次数据是什么格式。 Content-Type: text/html; charset=utf-8上面的类型表明，发送的是网页，而且编码是UTF-8。 客户端请求的时候，可以使用 Accept 字段声明自己可以接受哪些数据格式。 Accept: */*上面代码中，客户端声明自己可以接受任何格式的数据。 Content-Encoding 字段 Content-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式 Content-Encoding: gzip上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。 客户端在请求时，用 Accept-Encoding 字段说明自己可以接受哪些压缩方法。 Accept-Encoding: gzip, deflate GET 与 POST 说一下 GET 和 POST 的区别？ Get 方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等。 比如，你打开我的文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。 GET 请求 而POST 方法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报文的 body 里。 比如，你在我文章底部，敲入了留言后点击「提交」（暗示你们留言），浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。 POST 请求 GET 和 POST 方法都是安全和幂等的吗？ 先说明下安全和幂等的概念： 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。 那么很明显 GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。 POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。 03 HTTP 特性 你知道的 HTTP（1.1） 的优点有哪些，怎么体现的？ HTTP 最凸出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」。 1. 简单 HTTP 基本的报文格式就是 header + body，头部信息也是 key-value 简单文本的形式，易于理解，降低了学习和使用的门槛。 2. 灵活和易于扩展 HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。 同时 HTTP 由于是工作在应用层（ OSI 第七层），则它下层可以随意变化。 HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCPP 层换成了基于 UDP 的 QUIC。 3. 应用广泛和跨平台 互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用片地开花，同时天然具有跨平台的优越性。 那它的缺点呢？ HTTP 协议里有优缺点一体的双刃剑，分别是「无状态、明文传输」，同时还有一大缺点「不安全」。 1. 无状态双刃剑 无状态的好处，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。 无状态的坏处，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。 例如登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。 这样每操作一次，都要验证信息，这样的购物体验还能愉快吗？别问，问就是酸爽！ 对于无状态的问题，解法方案有很多种，其中比较简单的方式用 Cookie 技术。 Cookie 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。 相当于，在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了了， Cookie 技术 2. 明文传输双刃剑 明文意味着在传输过程中的信息，是可方便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。 但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于信息裸奔。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有你的账号密码信息，那你号没了。 3. 不安全 HTTP 比较严重的缺点就是不安全： 通信使用明文（不加密），内容可能会被窃听。比如，账号信息容易泄漏，那你号没了。 不验证通信方的身份，因此有可能遭遇伪装。比如，访问假的淘宝、拼多多，那你钱没了。 无法证明报文的完整性，所以有可能已遭篡改。比如，网页上植入垃圾广告，视觉污染，眼没了。 HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。 那你说下 HTTP/1.1 的性能如何？ HTTP 协议是基于 TCP/IP，并且使用了「请求 - 应答」的通信模式，所以性能的关键就在这两点里。 1. 长连接 早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。 为了解决上述 TCP 连接问题，HTTP/1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。 持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。 短连接与长连接 2. 管道网络传输 HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。 即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。 举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求。 管道网络传输 但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是 前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」。 3. 队头阻塞 「请求 - 应答」的模式加剧了 HTTP 的性能问题。 因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「队头阻塞」。好比上班的路上塞车。 队头阻塞 总之 HTTP/1.1 的性能一般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能。 04 HTTP 与 HTTPS HTTP 与 HTTPS 有哪些区别？ HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。 HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。 HTTP 的端口号是 80，HTTPS 的端口号是 443。 HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。 HTTPS 解决了 HTTP 的哪些问题？ HTTP 由于是明文传输，所以安全上存在以下三个风险： 窃听风险，比如通信链路上可以获取通信内容，用户号容易没。 篡改风险，比如强制入垃圾广告，视觉污染，用户眼容易瞎。 冒充风险，比如冒充淘宝网站，用户钱容易没。 HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议。 HTTP 与 HTTPS 可以很好的解决了上述的风险： 信息加密：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。 校验机制：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。 身份证书：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。 可见，只要自身不做「恶」，SSL/TLS 协议是能保证通信是安全的。 HTTPS 是如何解决上面的三个风险的？ 混合加密的方式实现信息的机密性，解决了窃听的风险。 摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。 将服务器公钥放入到数字证书中，解决了冒充的风险。 1. 混合加密 通过混合加密的方式可以保证信息的机密性，解决了窃听的风险。 混合加密 HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式： 在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。 在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。 采用「混合加密」的方式的原因： 对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。 2. 摘要算法 摘要算法用来实现完整性，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。 校验完整性 客户端在发送明文之前会通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」一同加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的「指纹」和当前算出的「指纹」做比较，若「指纹」相同，说明数据是完整的。 3. 数字证书 客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。 这就存在些问题，如何保证公钥不被篡改和信任度？ 所以这里就需要借助第三方权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。 数字证书工作流程 通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。 HTTPS 是如何建立连接的？其间交互了什么？ SSL/TLS 协议基本流程： 客户端向服务器索要并验证服务器的公钥。 双方协商生产「会话秘钥」。 双方采用「会话秘钥」进行加密通信。 前两步也就是 SSL/TLS 的建立过程，也就是握手阶段。 SSL/TLS 的「握手阶段」涉及四次通信，可见下图： HTTPS 连接建立过程 SSL/TLS 协议建立的详细流程： 1. ClientHello 首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。 在这一步，客户端主要向服务器发送以下信息： （1）客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。 （2）客户端生产的随机数（Client Random），后面用于生产「会话秘钥」。 （3）客户端支持的密码套件列表，如 RSA 加密算法。 2. SeverHello 服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容： （1）确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。 （2）服务器生产的随机数（Server Random），后面用于生产「会话秘钥」。 （3）确认的密码套件列表，如 RSA 加密算法。 （4）服务器的数字证书。 3.客户端回应 客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。 如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息： （1）一个随机数（pre-master key）。该随机数会被服务器公钥加密。 （2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。 （3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。 上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。 4. 服务器的最后回应 服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发生最后的信息： （1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。 （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。 至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。 05 HTTP/1.1、HTTP/2、HTTP/3 演变 说说 HTTP/1.1 相比 HTTP/1.0 提高了什么性能？ HTTP/1.1 相比 HTTP/1.0 性能上的改进： 使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。 支持 管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。 但 HTTP/1.1 还是有性能瓶颈： 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分； 发送冗长的首部。每次互相发送相同的首部造成的浪费较多； 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞； 没有请求优先级控制； 请求只能从客户端开始，服务器只能被动响应。 那上面的 HTTP/1.1 的性能瓶颈，HTTP/2 做了什么优化？ HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。 那 HTTP/2 相比 HTTP/1.1 性能上的改进： 1. 头部压缩 HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的分。 这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。 2. 二进制格式 HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式。 头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧。 报文区别 这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率。 3. 数据流 HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。 每个请求或回应的所有数据包，称为一个数据流（Stream）。 每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数 客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。 HTT/1 ~ HTTP/2 4. 多路复用 HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。 移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。 举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。 多路复用 5. 服务器推送 HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。 举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。 HTTP/2 有哪些缺陷？HTTP/3 做了哪些优化？ HTTP/2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。 所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。 HTTP/1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了 HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。 这都是基于 TCP 传输层的问题，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！ HTTP/1 ~ HTTP/3 UDP 发生是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的一个丢包全部重传问题。 大家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。 QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。 TL3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack。 HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。 TCP HTTPS（TLS/1.3） 和 QUIC HTTPS 所以， QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP/2 的多路复用的协议。 QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题。所以 HTTP/3 现在普及的进度非常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。 参考文献:[1] 上野 宣.图解HTTP.人民邮电出版社. [2] 罗剑锋.透视HTTP协议.极客时间. [3] 陈皓.HTTP的前世今.酷壳CoolShell. https://coolshell.cn/articles/19840.html [4] 阮一峰.HTTP 协议入门.阮一峰的网络日志. http://www.ruanyifeng.com/blog/2016/08/http.html END document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"oracle","slug":"oracle","permalink":"https://xkunchen.github.io/categories/oracle/"},{"name":"别人的优秀博客文章","slug":"oracle/别人的优秀博客文章","permalink":"https://xkunchen.github.io/categories/oracle/别人的优秀博客文章/"}],"tags":[{"name":"http","slug":"http","permalink":"https://xkunchen.github.io/tags/http/"},{"name":"别人的优秀博客文章","slug":"别人的优秀博客文章","permalink":"https://xkunchen.github.io/tags/别人的优秀博客文章/"}]},{"title":"oracle向mysql改造","slug":"Oracle向mysql改造","date":"2020-01-10T03:44:53.000Z","updated":"2020-03-04T03:28:19.560Z","comments":true,"path":"2020/01/10/oracle-xiang-mysql-gai-zao/","link":"","permalink":"https://xkunchen.github.io/2020/01/10/oracle-xiang-mysql-gai-zao/","excerpt":"前言​ 由于工作需要，把oracle数据库改造成mysql数据库，而oracle和mysql在一定程度上有很大的区别，我们的工作是在已有项目改bug，所以特地总结一下这几天项目需要的改动。","text":"前言​ 由于工作需要，把oracle数据库改造成mysql数据库，而oracle和mysql在一定程度上有很大的区别，我们的工作是在已有项目改bug，所以特地总结一下这几天项目需要的改动。 函数式报错start with connect by prior函数错误问题描述：​ 这个是oracle特有的一个函数，是根据条件递归查询”树”。注意递归查询，常用用法：start with connect by prior parentId=id或start with connect by prior id=parentId，第一种是：查询结果自己所有的后代节点（包括自己）；第二种用法是查询结果自己所有的父类节点（包括自己）。 解决方案：​ Mysql不支持通过start with connect by进行递归查询，所以创建函数进行查找。 ​ 首先是第一种：查询结果自己所有的后代节点（包括自己），首先得了解find_in_set这个函数作用，举个例子：find_in_set（parent_id,”1,2,3”）的意思是parent_id在1,2,3内。创建函数如下： create function getTaskObject --getTaskObject 函数名称 (rootId varchar(100)) --输入值类型 returns varchar(1024) --返回值类型 as begin DECLARE sTemp VARCHAR(1024); --定义变量 DECLARE sTempChd VARCHAR(1024);--定义变量 SET sTemp = ''; -- SET sTempChd = CAST(auth_id AS CHAR); SET sTempChd = auth_id; WHILE sTempChd IS NOT NULL DO --如果不空一直循环 IF sTemp = '' THEN SET sTemp = sTempChd; ELSE SET sTemp= CONCAT(sTemp,',',sTempChd); END IF; SELECT GROUP_CONCAT(id) INTO sTempChd FROM SBP_AUTH_ROLE WHERE FIND_IN_SET(parent_id,sTempChd)>0;--把所有的id拼接接起来 END WHILE;--结束循环 RETURN sTemp; --返回结果 end ​ 调用可以向平时调用内置函数一样调用，这个函数的返回值是所有符合条件id拼接起来字符串，所以我们调用也得加find_in_set(id,getTaskObject(值)) ​ 第二种：查询结果自己所有的父类节点，返回值也是所有符合条件id拼接起来字符串，所以我们调用也得加find_in_set(id,getTaskObject(子节点id)) create function getTaskObject --getTaskObject 函数名称 (rootId varchar(100)) --输入值类型 returns varchar(1024) --返回值类型 as BEGIN DECLARE sTemp VARCHAR(100); --定义变量 DECLARE sTempChd VARCHAR(100);--定义变量 DECLARE allData VARCHAR(1024);--定义变量 SET allData=''; SET sTempChd =cast(rootId as CHAR); SET sTemp=''; WHILE sTempChd IS NOT NULL DO --如果不空一直循环 SET sTemp=sTempChd; SET allData=CONCAT(allData,',',sTempChd); SELECT PARENT_ID INTO sTempChd FROM usbp_task_object where OBJECT_ID=sTemp; END WHILE; --结束循环 RETURN allData; --返回结果 END 延伸：传入的table为动态table表怎么办？​ 本以为这样写就可以全部用上，但这个有个明显的不足就是table只能写死，一开始的想法是把table传进去，但报错了，我是这样写的： Select parent_id into sTempChd from tableName(ps：这是个变量) where object_id=sTemp; ​ 会报tableName这个表不存在的错误，因为sql不会自动识别tableName这个变量，它会认为有这个tableName的表 。 ​ 网上查找了资料说可以用动态sql，但函数不支持动态sql，所以解决办法就是写一个存储过程，以下讲解的是第二种查询结果自己所有的父类节点，如下: CREATE PROCEDURE SELECT_TREE(IN keyColumn VARCHAR(32) CHARSET utf8,IN tableName VARCHAR(32) CHARSET utf8,IN parentColumn VARCHAR(32) CHARSET utf8, IN keyValue VARCHAR(64) CHARSET utf8,OUT returndata VARCHAR(2048) CHARSET utf8)--输入输出参数，in为输入，out为输出 BEGIN declare sTemp VARCHAR(100); --定义变量 SET sTemp = keyValue; SET returndata=''; WHILE sTemp IS NOT NULL DO--如果不空一直循环 -- 创建sql SET @selectSql = CONCAT('select ',parentColumn,' INTO @recordcount from ',tableName,' where ',keyColumn,\"='\",sTemp,\"'\"); -- 执行动态生成的sql语句 PREPARE temp FROM @selectSql; EXECUTE temp; SET sTemp = @recordcount;--其实对比上面仔细看可以看出只是这一步不同 IF sTemp IS NOT NULL THEN SET returndata=CONCAT(returndata,',',sTemp); END IF; END WHILE; --结束循环 END ​ 可以对比上面的自定义函数，一个注意地方是@recordcount 代替sTempChd 变量，声明这是个变量，其他是语法问题，逻辑和自定义函数相同。 ​ 然后就是调用测试，我是在Navicat测试的，我的版本可以直接传参（听说低版本不可以直接测试）。注意的是out输出参数要传递变量，如:(keycolum,tableName,pid,in,@returnData)。 ​ ​ 以上是在Navicat调用的，在项目中，我们需要写sql调用，用的是mybatis框架，调用如下，最重要是要加上statementType=”CALLABLE”，如果传入是map，returnData这个名字可以随便取，传入是pojo，这个值必须固定，在pojo里面应该有个同名变量。返回值去传入的参数里拿，这个我传入的是map，所以直接去传入的map拿了，至于传入pojo要给个变量returnData，会自动注入。 ​ &lt;mapper namespace=\"com.shd.biz.Tree.service.impl.TreeServiceImpl\"> &lt;!-- 注意 statementType=\"CALLABLE\" --> &lt;select id=\"treeParent\" statementType=\"CALLABLE\"> {call SELECT_TREE( #{keyColumn,mode=IN},#{tableName,mode=IN},#{parentColumn,mode=IN},#{keyValue,mode=IN} ,#{returnData,mode=OUT,jdbcType=VARCHAR})} &lt;/select> &lt;/mapper> ​ Map&lt;String, Object> parameters=new HashMap&lt;String, Object>(); parameters.put(\"keyValue\", value); parameters.put(\"tableName\", table); parameters.put(\"keyColumn\", keyColumn); parameters.put(\"parentColumn\", parentColumn); this.getDao().queryForDataSet(SQL_PRIFIX + \"treeParent\", parameters); //结果是从传入参数里面拿，不是从返回结果拿 String returnData = parameters.get(\"returnData\").toString(); 调用报方法read-Only错误​ 最后还有个报错是事务报错，是因为我项目get开头的方法设置了readOnly=”true”，而调用存储过程如果还设置readOnly属性就会报错，要加上@Transactional(readOnly = false)或改变service方法名。 Sysdate报错​ 解决Sysdate替换为sysdate() to_char报错​ 网上查找的资料： ​ date_format(date,’%Y-%m-%d’) ————–&gt;oracle中的to_char(); ​ str_to_date(date,’%Y-%m-%d’) ————–&gt;oracle中的to_date(); ​ 日期的计算​ oracle 可以直接用sysdate加减乘除，而mysql不可以，如 近一个月： ​ Oracle——–&gt;sysdate-29 ​ Mysql———&gt; &lt;if test=\"REPORT_TIME == '本周'\"> and YEARWEEK(date_format(report_time,'%Y-%m-%d')) = YEARWEEK(now()) &lt;/if> &lt;if test=\"REPORT_TIME == '本月'\"> and report_time >=DATE_ADD(curdate(),interval -day(curdate())+1 day) and report_time &amp;lt;= last_day(SYSDATE()) &lt;/if> &lt;if test=\"REPORT_TIME == '近1个月'\"> and report_time BETWEEN date_sub(SYSDATE(),interval 1 month) AND SYSDATE() &lt;/if> &lt;if test=\"REPORT_TIME == '近3个月'\"> and report_time BETWEEN date_sub(SYSDATE(),interval 3 month) AND SYSDATE() &lt;/if> &lt;if test=\"REPORT_TIME == '近1年'\"> and report_time BETWEEN date_sub(SYSDATE(),interval 12 month) AND SYSDATE() &lt;/if> Rownum报错​ 在mysql中没有Rownum，所以要特殊的实现方法，实现和效果如下，但我项目是用来分页，所以直接就用limit。 ​ SELECT @rownum:=@rownum+1 AS rownum, table .* FROM (SELECT @rownum:=0) r, table ; ||运算符报错​ Mysql中||表示或的意识，而Oracle中||运算符可以将两个或两个以上的字符串连接在一起，在mysql中用concat代替。 其他报错表别名报错 别名报错，首先mysql不可以像Oracle一样直接多重查找不加别名，如： Select key from(select key from database); 改为Select t.key from(select key from database) t; 但在删除时又不可以加别名，如 ： Delete from database r where r.id=?会报错，得改为: Delete from database where id=? Mysql没有序列问题存储类型bigInteger装换toBigDecimal​ 原来oracle存储数据类型是integer，现在存储类型为decimal，启动时报错，bigInteger cannot to cast toBigDecimal，所以，就得装换一下。 这是详情 union报错​ Oracle的union和mysql的union的一个细节错误导致，oracle可以用括号括起来，而mysql不可以 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"oracle","slug":"oracle","permalink":"https://xkunchen.github.io/categories/oracle/"},{"name":"mysql","slug":"oracle/mysql","permalink":"https://xkunchen.github.io/categories/oracle/mysql/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"https://xkunchen.github.io/tags/oracle/"},{"name":"mysql","slug":"mysql","permalink":"https://xkunchen.github.io/tags/mysql/"}]}]}